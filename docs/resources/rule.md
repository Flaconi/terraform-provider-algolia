---
# generated by https://github.com/hashicorp/terraform-plugin-docs
page_title: "algolia_rule Resource - terraform-provider-algolia"
subcategory: ""
description: |-
  A configuration for a Rule
---

# algolia_rule (Resource)

A configuration for a Rule

## Example Usage

```terraform
resource "algolia_rule" "example" {
  index_name = "example_index"
  object_id  = "example"

  conditions {
    pattern   = "{facet:category}"
    anchoring = "contains"
  }

  consequence {
    params {
      automatic_facet_filters {
        facet       = "category"
        disjunctive = true
      }
    }
  }
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- **consequence** (Block List, Min: 1, Max: 1) Consequence of the Rule. 
At least one of the following object must be used:
- params
- promote
- hide
- user_data (see [below for nested schema](#nestedblock--consequence))
- **index_name** (String) Name of the index to apply rule.
- **object_id** (String) Unique identifier for the Rule (format: `[A-Za-z0-9_-]+`).

### Optional

- **conditions** (Block List) A list of conditions that should apply to activate a Rule. You can use up to 25 conditions per Rule. (see [below for nested schema](#nestedblock--conditions))
- **description** (String) This field is intended for Rule management purposes, in particular to ease searching for Rules and presenting them to human readers. It is not interpreted by the API.
- **enabled** (Boolean) Whether the Rule is enabled. Disabled Rules remain in the index, but are not applied at query time.
- **id** (String) The ID of this resource.
- **validity** (Block List) Objects to promote as hits. (see [below for nested schema](#nestedblock--validity))

<a id="nestedblock--consequence"></a>
### Nested Schema for `consequence`

Optional:

- **hide** (Set of String) List of object IDs to hide from hits.
- **params** (Block List, Max: 1) Additional search parameters. Any valid search parameter is allowed. Specific treatment is applied to these fields: `query`, `automaticFacetFilters`, `automaticOptionalFacetFilters`. (see [below for nested schema](#nestedblock--consequence--params))
- **promote** (Block List) Objects to promote as hits. (see [below for nested schema](#nestedblock--consequence--promote))
- **user_data** (String) Custom JSON formatted string that will be appended to the userData array in the response. This object is not interpreted by the API. It is limited to 1kB of minified JSON.

<a id="nestedblock--consequence--params"></a>
### Nested Schema for `consequence.params`

Optional:

- **automatic_facet_filters** (Block List) Names of facets to which automatic filtering must be applied; they must match the facet name of a facet value placeholder in the query pattern. (see [below for nested schema](#nestedblock--consequence--params--automatic_facet_filters))
- **automatic_optional_facet_filters** (Block List) Same syntax as `automatic_facet_filters`, but the engine treats the filters as optional. Behaves like [optionalFilters](https://www.algolia.com/doc/api-reference/api-parameters/optionalFilters/). (see [below for nested schema](#nestedblock--consequence--params--automatic_optional_facet_filters))
- **object_query** (Block List, Max: 1) It describes incremental edits to be made to the query string. Either one of `query` or `object_query` can be set. (see [below for nested schema](#nestedblock--consequence--params--object_query))
- **query** (String) It replaces the entire query string. Either one of `query` or `object_query` can be set.

<a id="nestedblock--consequence--params--automatic_facet_filters"></a>
### Nested Schema for `consequence.params.automatic_facet_filters`

Required:

- **facet** (String) Attribute to filter on. This must match a facet placeholder in the Rule’s pattern.

Optional:

- **disjunctive** (Boolean) Whether the filter is disjunctive (true) or conjunctive (false). If the filter applies multiple times, e.g. because the query string contains multiple values of the same facet, the multiple occurrences are combined with an `AND` operator by default (conjunctive mode). If the filter is specified as disjunctive, however, multiple occurrences are combined with an `OR` operator instead.
- **score** (Number) Score for the filter. Typically used for optional or disjunctive filters.


<a id="nestedblock--consequence--params--automatic_optional_facet_filters"></a>
### Nested Schema for `consequence.params.automatic_optional_facet_filters`

Required:

- **facet** (String) Attribute to filter on. This must match a facet placeholder in the Rule’s pattern.

Optional:

- **disjunctive** (Boolean) Whether the filter is disjunctive (true) or conjunctive (false). If the filter applies multiple times, e.g. because the query string contains multiple values of the same facet, the multiple occurrences are combined with an `AND` operator by default (conjunctive mode). If the filter is specified as disjunctive, however, multiple occurrences are combined with an `OR` operator instead.
- **score** (Number) Score for the filter. Typically used for optional or disjunctive filters.


<a id="nestedblock--consequence--params--object_query"></a>
### Nested Schema for `consequence.params.object_query`

Required:

- **delete** (String) Text or patterns to remove from the query string.
- **type** (String) Type of edit. Must be one of:
- `remove`: when you want to delete some text and not replace it with anything
- `replace`: when you want to delete some text and replace it with something else

Optional:

- **insert** (String) Text that should be inserted in place of the removed text inside the query string.



<a id="nestedblock--consequence--promote"></a>
### Nested Schema for `consequence.promote`

Required:

- **object_ids** (Set of String)
- **position** (Number) The position to promote the object(s) to (zero-based). If you pass `object_ids`, we place the objects at this position as a group. For example, if you pass four `object_ids` to position `0`, the objects take the first four positions.



<a id="nestedblock--conditions"></a>
### Nested Schema for `conditions`

Optional:

- **alternatives** (Boolean) Whether the `pattern` matches on plurals, synonyms, and typos.

This parameter goes hand in hand with the `pattern`  parameter. If the `pattern` is “shoe” and `alternatives` is `true`, the `pattern` matches on “shoes”, as well as synonyms and typos of “shoe”.
- **anchoring** (String) Whether the pattern parameter must match the beginning or the end of the query string, or both, or none.
Possible values are `is`, `startsWith`, `endsWith` and `contains`.
This parameter goes hand in hand with the `pattern` parameter. If you’re creating a Rule that depends on a specific query, you must specify the `pattern` and `anchoring`.

Otherwise, you can omit both.
- **context** (String) Rule context (format: `[A-Za-z0-9_-]+`). When specified, the Rule is only applied when the same context is specified at query time (using the `ruleContexts` parameter). When absent, the Rule is generic and always applies (provided that its other conditions are met, of course).
- **pattern** (String) Query pattern syntax.
Query patterns are expressed as a string with a specific syntax. A pattern is a sequence of tokens, which can be either:

- Facet value placeholder: `{facet:$facet_name}`. Example: `{facet:brand}`.
- Literal: the world itself. Example: Algolia.
Special characters (`*`, `{`, `}`, `:` and `\`) must be escaped by preceding them with a backslash (\) if they are to be treated as literals.

This parameter goes hand in hand with the `anchoring` parameter. If you’re creating a Rule that depends on a specific query, you must specify the pattern and anchoring. The empty `""` pattern is only allowed when `anchoring` is set to `is`.

Otherwise, you can omit both.


<a id="nestedblock--validity"></a>
### Nested Schema for `validity`

Required:

- **from** (Number) Lower bound of the time range (Unix timestamp).
- **until** (Number) Upper bound of the time range (Unix timestamp).

## Import

Import is supported using the following syntax:

```shell
terraform import algolia_index.default {{index_name}}/{{object_id}}
```
